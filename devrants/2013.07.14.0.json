{"content":"<p>No matter how well you happen to understand the concepts of writing software and using one (or more) languages, there's always small conventions or little features that hang out under your radar for longer than they should. To be honest, that's the case for a lot of things even outside the world of development, but software development is a place where those little things can be immediately applied to everything, which is exciting.<\/p>\r\n\r\n<p>The other day, I discovered lambdas in Python, while refining some of the action handlers for the GUI of my project tracking application. I've heard of lambdas but had just never gotten around to really learning what they were. They were on my list of things to \"discover\" somewhere around regex. I just hadn't gotten to really looking into them because they didn't sound like something I would use often, and so I wasn't going to dive into them, especially since I was pushing to learn TKinter.<\/p>\r\n\r\n<p>What ended up happening was that while trying to build the main window of my application, I wanted to make it as flexible as possible. The main window essentially consists of a listbox where I'm displaying the list of projects in various forms - sorted list, simple histograms, and things of that nature. The application also needed to be able to refresh the contents of the listbox to show newly added projects, remove deleted projects, and to update for modifications and new task logs. I was accomplishing this with a class property that stored the function for the current view, which was called anytime a child window informed the main window that there was a change in the data. This worked fine and was, in my opinion, a fairly slick way of doing it. The problem arose when I wanted to have some custom sorting or filtering of the list, because it's not possible to hard code filters and such where data is changing without any particular bounds. This is where lambdas came in.<\/p>\r\n\r\n<p>In Python, everything is an object, so it's possible to pass functions around as objects and call them, which was what I was doing. However, TKinter doesn't allow for functions to be called with arguments, which put me into an unfamiliar place while adding functionality. My basic functions, which didn't need arguments, looked like:<\/p>\r\n\r\n<code>\r\ndef viewProjectList( self ):<br \/>\r\n&nbsp;   self.currentView = self.viewProjectList <br \/>\r\n&nbsp;   ...<br \/>\r\ndef viewLineHistogram( self ): <br \/>\r\n&nbsp;   self.currentView = self.viewLineHistogram<br \/>\r\n&nbsp;   ...<br \/>\r\ndef refreshView( self ):<br \/>\r\n&nbsp;   self.currentView()<br \/>\r\n<\/code><br \/>\r\n\r\n<p>However, in order to accomplish filtering the views dynamically based on what the user wanted, I needed to pass arguments. Lambdas allow you to create function objects that include arguments, which was exactly what I needed:<\/p>\r\n\r\n<code>\r\ndef viewProjectByStatus( self, status ):<br \/>\r\n&nbsp;   self.currentView = lambda s=status: self.viewProjectByStatus( s )<br \/>\r\n&nbsp;   ...<br \/>\r\n<\/code><br \/>\r\n\r\n<p>The really exciting thing was how useful I found that to be. In a span of about 15 minutes, I was using lambdas all over the place in both my project tracking application and various other applications where I had hacked together somewhat messy code to accomplish something similar. It took me a couple minutes to figure out how to use them, and now I'm not sure how (or why) I was getting on without them. It's always the simple things that turn out to be the most useful and sometimes the most exciting.<\/p>","title":"Learning Lambdas","date":null,"tags":"workflow, learning","datestamp":"2013-07-14T13:58:49-05:00","updated":"2013-07-14T13:58:49-05:00"}